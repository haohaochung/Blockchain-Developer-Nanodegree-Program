var SquareVerifier = artifacts.require('SquareVerifier');
var SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
const proof = require('../../zokrates/code/square/proof1.json');
const proof2 = require('../../zokrates/code/square/proof1.json');

contract('SolnSquareVerifier', (accounts) => {
    let soln;
    let verifier;

    function mintWithValidProof1() {
        return soln.mint(
            accounts[0],
            proof.proof.A,
            proof.proof.A_p,
            proof.proof.B,
            proof.proof.B_p,
            proof.proof.C,
            proof.proof.C_p,
            proof.proof.H,
            proof.proof.K,
            proof.input
        );
    }

    describe('Test verification with proof generated by Zokrates', () => {

        beforeEach(async () => { 
            verifier = await SquareVerifier.new({ from: accounts[0] });
            soln = await SolnSquareVerifier.new(verifier.address, {from: accounts[0] });

        });
        
        // Test if a new solution can be added for contract - SolnSquareVerifier
        it('if a new solution can be added for contract',async function(){
            let canAdd = true;
            try {
                await soln.canMintToken(
                    accounts[0],
                    proof.proof.A,
                    proof.proof.A_p,
                    proof.proof.B,
                    proof.proof.B_p,
                    proof.proof.C,
                    proof.proof.C_p,
                    proof.proof.H,
                    proof.proof.K,
                    proof.input, 
                );
            } catch(e) {
                canAdd = false;
            }
            assert.equal(canAdd, true, "Solution cannot be added");
        }) 

        // Test if an ERC721 token can be minted for contract - SolnSquareVerifier
        it('Can mint a ERC721 if the proof is valid', async () => { 
            await mintWithValidProof1();
            assert.equal(await soln.totalSupply(), 1);
        });

        it('reverts if proof is not valid', async () => {
            let isReverted = false;
            try {
              const cheatInput = [123, 123];
              await soln.mint(
                accounts[0],
                proof.proof.A,
                proof.proof.A_p,
                proof.proof.B,
                proof.proof.B_p,
                proof.proof.C,
                proof.proof.C_p,
                proof.proof.H,
                proof.proof.K,
                cheatInput
              );
            } catch (error) {
              isReverted = true;
            }
            assert.equal(isReverted, true);
          });

       
    });
});
    
